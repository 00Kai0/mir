# C to MIR compiler
  * Implementation of a small C11 (2011 ANSI C standard) to MIR compiler
    * no optional features: variable size arrays, complex, atomic
  * Minimal compiler code dependency.  No additional tools (like yacc/flex) are used
  * Simplicity of implementation over speed to make code easy to learn and maintain
    * Four passes to divide compilation on manageable sub-tasks:
      1. Preprocessor pass generating tokens
      2. Parsing pass generating AST (Abstract Syntax Tree). To be close ANSI standard grammar
         as soon as possible, [**PEG**](https://en.wikipedia.org/wiki/Parsing_expression_grammar)
         manual parser is used
      3. Context pass checking context constraints and augmenting AST
      4. Generation pass producing MIR

  ![C to MIR](c2mir.svg)

## How to use C to MIR compiler
  * The compiler has options `-E`, `-c`, `-S`, and `-o` as other C compilers:
    * `-E` stops the compiler after preprocessing and output the
      preprocessed file into standard output or into file given after
      option `-o`
    * `-S` stops the compiler after generation of MIR code and outputs
      MIR *textual* representations of C source files
    * `-c` also stops the compiler after generation of MIR code and
      outputs MIR *binary* representation of C source files
    * Output files for options `-S` and `-c` are created in the
      current directory named as the source files by using suffix
      correspondingly `.mir` and `.bmir`
    * If you have one source file, you also can use option `-o` to setup the output file
  * You can give C source on the command line by using option `-s` and
    subsequent string which will be C source
  * You can read C source from the standard input by using option `-i`
  * If options `-E`, `-c`, or `-S` are not given, all generated MIR
    code is linked and checked that there is function `main`.  The
    whole generated code is output as binary MIR file `a.bmir` or as
    file given by option `-o`
  * Instead of output of the linked file, you can execute the program by using options `-ei`, `-eg`, or `-el`:
    * `-ei` means execution the code by MIR interpreter
    * `-eg` means execution machine code generated by
      MIR-generator. MIR-generator processing all MIR code first
      before the interpreter
    * `-el` means lazy code generation. It is analogous to `-eg` but
      function code is generated on the first call of the function.
      So machine code will be never generated for functions never used
    * Command line arguments after option `-ei`, `-eg`, or `-el` are
      not processed by C to MIR compiler. Such arguments are passed to
      generated and executed MIR program
    * The executed program can use functions from libraries `libc` and `libm`.  They are always available
    * To generate stand-alone executable see utility `b2ctab` description in directory `mir-utils`
  * Options `-D` and `-U` are analogous to ones used in other C
    compilers for macro manipulations on the command line
  * Option `-I` to add include directory is analogous to other C-compilers
  * Option `-fpreprocessed` means skipping preprocessor for C files
  * Option `-fsyntax-only` means stopping after parsing and semantic
    checking of C files without MIR code generation
  * Option `-pedantic` is used for stricter diagnostic about C
    standard conformance.  It might be useful as C2MIR implements some GCC extensions of C
    standard
  * Besides C files, MIR textual files with suffix `.mir` and MIR
    binary files with suffix `.bmir` can be given on the command line.
    In this case these MIR files are read and added to generated MIR code
  * Simple examples of the compiler usage and execution of C program:
```
	c2m -c part1.c && c2m -S part2.c && c2m part1.bmir part2.mir -eg # variant 1
	c2m part1.c part2.c && c2m a.bmir -eg                            # variant 2
	c2m part1.c part2.c -eg                                          # variant 3
```

## Current state C to MIR compiler
  * **On Oct 25 we achieved a successful bootstrap**
    * `c2m` compiles own sources and generate binary MIR, this binary
      MIR compiles `c2m` sources again and generate another binary
      MIR, and the two binary MIR files are identical
    * The bootstrap test takes about CPU 10 sec (for comparison GCC minimal bootstrap takes about 2 CPU hours)    
  * Full x86-64 call ABI (multiple return regs, passing structures through regs) is not implemented yet
